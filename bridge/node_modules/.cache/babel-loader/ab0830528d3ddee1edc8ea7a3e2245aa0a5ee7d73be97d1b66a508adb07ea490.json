{"ast":null,"code":"/**\r\n * Error Monitoring and Reporting System\r\n * Provides comprehensive error tracking and reporting for the application\r\n */\n\nexport class ErrorMonitor {\n  constructor() {\n    this.errors = [];\n    this.maxErrors = 100; // Keep last 100 errors\n    this.errorCounts = new Map();\n    this.isInitialized = false;\n  }\n\n  /**\r\n   * Initialize error monitoring\r\n   */\n  initialize() {\n    if (this.isInitialized) return;\n\n    // Global error handler\n    window.addEventListener('error', event => {\n      this.captureError({\n        type: 'javascript',\n        message: event.message,\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n        error: event.error,\n        timestamp: new Date().toISOString()\n      });\n    });\n\n    // Unhandled promise rejection handler\n    window.addEventListener('unhandledrejection', event => {\n      var _event$reason;\n      this.captureError({\n        type: 'promise',\n        message: ((_event$reason = event.reason) === null || _event$reason === void 0 ? void 0 : _event$reason.message) || 'Unhandled promise rejection',\n        reason: event.reason,\n        timestamp: new Date().toISOString()\n      });\n    });\n\n    // React error boundary integration\n    this.setupReactErrorCapture();\n    this.isInitialized = true;\n    console.log('Error monitoring initialized');\n  }\n\n  /**\r\n   * Capture an error\r\n   * @param {object} errorData - Error data to capture\r\n   */\n  captureError(errorData) {\n    var _errorData$error;\n    const enrichedError = {\n      id: this.generateErrorId(),\n      ...errorData,\n      url: window.location.href,\n      userAgent: navigator.userAgent,\n      timestamp: errorData.timestamp || new Date().toISOString(),\n      stackTrace: ((_errorData$error = errorData.error) === null || _errorData$error === void 0 ? void 0 : _errorData$error.stack) || 'No stack trace available'\n    };\n\n    // Add to errors array\n    this.errors.unshift(enrichedError);\n\n    // Keep only the last maxErrors\n    if (this.errors.length > this.maxErrors) {\n      this.errors = this.errors.slice(0, this.maxErrors);\n    }\n\n    // Update error counts\n    const errorKey = `${errorData.type}:${errorData.message}`;\n    this.errorCounts.set(errorKey, (this.errorCounts.get(errorKey) || 0) + 1);\n\n    // Log error\n    console.error('Error captured:', enrichedError);\n\n    // Check if this is a critical error\n    if (this.isCriticalError(enrichedError)) {\n      this.handleCriticalError(enrichedError);\n    }\n\n    // Report to external service (if configured)\n    this.reportError(enrichedError);\n  }\n\n  /**\r\n   * Generate unique error ID\r\n   * @returns {string} - Unique error ID\r\n   */\n  generateErrorId() {\n    return `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\r\n   * Check if error is critical\r\n   * @param {object} errorData - Error data\r\n   * @returns {boolean} - Whether error is critical\r\n   */\n  isCriticalError(errorData) {\n    const criticalKeywords = ['navigation', 'authentication', 'network', 'chunk', 'module'];\n    return criticalKeywords.some(keyword => errorData.message.toLowerCase().includes(keyword));\n  }\n\n  /**\r\n   * Handle critical errors\r\n   * @param {object} errorData - Critical error data\r\n   */\n  handleCriticalError(errorData) {\n    console.error('CRITICAL ERROR DETECTED:', errorData);\n\n    // Could trigger user notification\n    // this.notifyUser('A critical error occurred. The page may need to be refreshed.');\n\n    // Could trigger automatic recovery\n    // this.attemptRecovery(errorData);\n  }\n\n  /**\r\n   * Report error to external service\r\n   * @param {object} errorData - Error data to report\r\n   */\n  reportError(errorData) {\n    // This would integrate with error reporting services like Sentry, LogRocket, etc.\n    // For now, we'll just log it\n    if (process.env.NODE_ENV === 'production') {\n      // In production, you would send to error reporting service\n      console.log('Would report error to external service:', errorData);\n    }\n  }\n\n  /**\r\n   * Setup React error boundary integration\r\n   */\n  setupReactErrorCapture() {\n    // This method can be called by error boundaries to report React errors\n    window.captureReactError = (error, errorInfo, componentName) => {\n      this.captureError({\n        type: 'react',\n        message: error.message,\n        componentName,\n        error,\n        errorInfo,\n        timestamp: new Date().toISOString()\n      });\n    };\n  }\n\n  /**\r\n   * Get error statistics\r\n   * @returns {object} - Error statistics\r\n   */\n  getErrorStats() {\n    const now = new Date();\n    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);\n    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n    const recentErrors = this.errors.filter(error => new Date(error.timestamp) > oneHourAgo);\n    const dailyErrors = this.errors.filter(error => new Date(error.timestamp) > oneDayAgo);\n    const errorsByType = {};\n    this.errors.forEach(error => {\n      errorsByType[error.type] = (errorsByType[error.type] || 0) + 1;\n    });\n    return {\n      totalErrors: this.errors.length,\n      recentErrors: recentErrors.length,\n      dailyErrors: dailyErrors.length,\n      errorsByType,\n      topErrors: this.getTopErrors(),\n      criticalErrors: this.errors.filter(error => this.isCriticalError(error)).length\n    };\n  }\n\n  /**\r\n   * Get top errors by frequency\r\n   * @param {number} limit - Number of top errors to return\r\n   * @returns {Array} - Top errors\r\n   */\n  getTopErrors(limit = 5) {\n    return Array.from(this.errorCounts.entries()).sort((a, b) => b[1] - a[1]).slice(0, limit).map(([error, count]) => ({\n      error,\n      count\n    }));\n  }\n\n  /**\r\n   * Get recent errors\r\n   * @param {number} limit - Number of recent errors to return\r\n   * @returns {Array} - Recent errors\r\n   */\n  getRecentErrors(limit = 10) {\n    return this.errors.slice(0, limit);\n  }\n\n  /**\r\n   * Clear error history\r\n   */\n  clearErrors() {\n    this.errors = [];\n    this.errorCounts.clear();\n    console.log('Error history cleared');\n  }\n\n  /**\r\n   * Export error data\r\n   * @returns {object} - Exportable error data\r\n   */\n  exportErrorData() {\n    return {\n      errors: this.errors,\n      stats: this.getErrorStats(),\n      exportTime: new Date().toISOString()\n    };\n  }\n}\n\n// Create singleton instance\nexport const errorMonitor = new ErrorMonitor();\n\n/**\r\n * Initialize error monitoring\r\n */\nexport const initializeErrorMonitoring = () => {\n  errorMonitor.initialize();\n};\n\n/**\r\n * Capture a custom error\r\n * @param {string} message - Error message\r\n * @param {object} context - Additional context\r\n */\nexport const captureCustomError = (message, context = {}) => {\n  errorMonitor.captureError({\n    type: 'custom',\n    message,\n    context,\n    timestamp: new Date().toISOString()\n  });\n};\n\n/**\r\n * Get error monitoring dashboard data\r\n * @returns {object} - Dashboard data\r\n */\nexport const getErrorDashboardData = () => {\n  return {\n    stats: errorMonitor.getErrorStats(),\n    recentErrors: errorMonitor.getRecentErrors(),\n    topErrors: errorMonitor.getTopErrors()\n  };\n};\nexport default ErrorMonitor;","map":{"version":3,"names":["ErrorMonitor","constructor","errors","maxErrors","errorCounts","Map","isInitialized","initialize","window","addEventListener","event","captureError","type","message","filename","lineno","colno","error","timestamp","Date","toISOString","_event$reason","reason","setupReactErrorCapture","console","log","errorData","_errorData$error","enrichedError","id","generateErrorId","url","location","href","userAgent","navigator","stackTrace","stack","unshift","length","slice","errorKey","set","get","isCriticalError","handleCriticalError","reportError","now","Math","random","toString","substr","criticalKeywords","some","keyword","toLowerCase","includes","process","env","NODE_ENV","captureReactError","errorInfo","componentName","getErrorStats","oneHourAgo","getTime","oneDayAgo","recentErrors","filter","dailyErrors","errorsByType","forEach","totalErrors","topErrors","getTopErrors","criticalErrors","limit","Array","from","entries","sort","a","b","map","count","getRecentErrors","clearErrors","clear","exportErrorData","stats","exportTime","errorMonitor","initializeErrorMonitoring","captureCustomError","context","getErrorDashboardData"],"sources":["D:/MCA/BPUT_Hackathon/Last_hope/bridge/src/utils/errorMonitoring.js"],"sourcesContent":["/**\r\n * Error Monitoring and Reporting System\r\n * Provides comprehensive error tracking and reporting for the application\r\n */\r\n\r\nexport class ErrorMonitor {\r\n  constructor() {\r\n    this.errors = [];\r\n    this.maxErrors = 100; // Keep last 100 errors\r\n    this.errorCounts = new Map();\r\n    this.isInitialized = false;\r\n  }\r\n\r\n  /**\r\n   * Initialize error monitoring\r\n   */\r\n  initialize() {\r\n    if (this.isInitialized) return;\r\n\r\n    // Global error handler\r\n    window.addEventListener('error', (event) => {\r\n      this.captureError({\r\n        type: 'javascript',\r\n        message: event.message,\r\n        filename: event.filename,\r\n        lineno: event.lineno,\r\n        colno: event.colno,\r\n        error: event.error,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n    });\r\n\r\n    // Unhandled promise rejection handler\r\n    window.addEventListener('unhandledrejection', (event) => {\r\n      this.captureError({\r\n        type: 'promise',\r\n        message: event.reason?.message || 'Unhandled promise rejection',\r\n        reason: event.reason,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n    });\r\n\r\n    // React error boundary integration\r\n    this.setupReactErrorCapture();\r\n\r\n    this.isInitialized = true;\r\n    console.log('Error monitoring initialized');\r\n  }\r\n\r\n  /**\r\n   * Capture an error\r\n   * @param {object} errorData - Error data to capture\r\n   */\r\n  captureError(errorData) {\r\n    const enrichedError = {\r\n      id: this.generateErrorId(),\r\n      ...errorData,\r\n      url: window.location.href,\r\n      userAgent: navigator.userAgent,\r\n      timestamp: errorData.timestamp || new Date().toISOString(),\r\n      stackTrace: errorData.error?.stack || 'No stack trace available'\r\n    };\r\n\r\n    // Add to errors array\r\n    this.errors.unshift(enrichedError);\r\n    \r\n    // Keep only the last maxErrors\r\n    if (this.errors.length > this.maxErrors) {\r\n      this.errors = this.errors.slice(0, this.maxErrors);\r\n    }\r\n\r\n    // Update error counts\r\n    const errorKey = `${errorData.type}:${errorData.message}`;\r\n    this.errorCounts.set(errorKey, (this.errorCounts.get(errorKey) || 0) + 1);\r\n\r\n    // Log error\r\n    console.error('Error captured:', enrichedError);\r\n\r\n    // Check if this is a critical error\r\n    if (this.isCriticalError(enrichedError)) {\r\n      this.handleCriticalError(enrichedError);\r\n    }\r\n\r\n    // Report to external service (if configured)\r\n    this.reportError(enrichedError);\r\n  }\r\n\r\n  /**\r\n   * Generate unique error ID\r\n   * @returns {string} - Unique error ID\r\n   */\r\n  generateErrorId() {\r\n    return `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  /**\r\n   * Check if error is critical\r\n   * @param {object} errorData - Error data\r\n   * @returns {boolean} - Whether error is critical\r\n   */\r\n  isCriticalError(errorData) {\r\n    const criticalKeywords = [\r\n      'navigation',\r\n      'authentication',\r\n      'network',\r\n      'chunk',\r\n      'module'\r\n    ];\r\n\r\n    return criticalKeywords.some(keyword => \r\n      errorData.message.toLowerCase().includes(keyword)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Handle critical errors\r\n   * @param {object} errorData - Critical error data\r\n   */\r\n  handleCriticalError(errorData) {\r\n    console.error('CRITICAL ERROR DETECTED:', errorData);\r\n    \r\n    // Could trigger user notification\r\n    // this.notifyUser('A critical error occurred. The page may need to be refreshed.');\r\n    \r\n    // Could trigger automatic recovery\r\n    // this.attemptRecovery(errorData);\r\n  }\r\n\r\n  /**\r\n   * Report error to external service\r\n   * @param {object} errorData - Error data to report\r\n   */\r\n  reportError(errorData) {\r\n    // This would integrate with error reporting services like Sentry, LogRocket, etc.\r\n    // For now, we'll just log it\r\n    if (process.env.NODE_ENV === 'production') {\r\n      // In production, you would send to error reporting service\r\n      console.log('Would report error to external service:', errorData);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Setup React error boundary integration\r\n   */\r\n  setupReactErrorCapture() {\r\n    // This method can be called by error boundaries to report React errors\r\n    window.captureReactError = (error, errorInfo, componentName) => {\r\n      this.captureError({\r\n        type: 'react',\r\n        message: error.message,\r\n        componentName,\r\n        error,\r\n        errorInfo,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get error statistics\r\n   * @returns {object} - Error statistics\r\n   */\r\n  getErrorStats() {\r\n    const now = new Date();\r\n    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);\r\n    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);\r\n\r\n    const recentErrors = this.errors.filter(error => \r\n      new Date(error.timestamp) > oneHourAgo\r\n    );\r\n\r\n    const dailyErrors = this.errors.filter(error => \r\n      new Date(error.timestamp) > oneDayAgo\r\n    );\r\n\r\n    const errorsByType = {};\r\n    this.errors.forEach(error => {\r\n      errorsByType[error.type] = (errorsByType[error.type] || 0) + 1;\r\n    });\r\n\r\n    return {\r\n      totalErrors: this.errors.length,\r\n      recentErrors: recentErrors.length,\r\n      dailyErrors: dailyErrors.length,\r\n      errorsByType,\r\n      topErrors: this.getTopErrors(),\r\n      criticalErrors: this.errors.filter(error => this.isCriticalError(error)).length\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get top errors by frequency\r\n   * @param {number} limit - Number of top errors to return\r\n   * @returns {Array} - Top errors\r\n   */\r\n  getTopErrors(limit = 5) {\r\n    return Array.from(this.errorCounts.entries())\r\n      .sort((a, b) => b[1] - a[1])\r\n      .slice(0, limit)\r\n      .map(([error, count]) => ({ error, count }));\r\n  }\r\n\r\n  /**\r\n   * Get recent errors\r\n   * @param {number} limit - Number of recent errors to return\r\n   * @returns {Array} - Recent errors\r\n   */\r\n  getRecentErrors(limit = 10) {\r\n    return this.errors.slice(0, limit);\r\n  }\r\n\r\n  /**\r\n   * Clear error history\r\n   */\r\n  clearErrors() {\r\n    this.errors = [];\r\n    this.errorCounts.clear();\r\n    console.log('Error history cleared');\r\n  }\r\n\r\n  /**\r\n   * Export error data\r\n   * @returns {object} - Exportable error data\r\n   */\r\n  exportErrorData() {\r\n    return {\r\n      errors: this.errors,\r\n      stats: this.getErrorStats(),\r\n      exportTime: new Date().toISOString()\r\n    };\r\n  }\r\n}\r\n\r\n// Create singleton instance\r\nexport const errorMonitor = new ErrorMonitor();\r\n\r\n/**\r\n * Initialize error monitoring\r\n */\r\nexport const initializeErrorMonitoring = () => {\r\n  errorMonitor.initialize();\r\n};\r\n\r\n/**\r\n * Capture a custom error\r\n * @param {string} message - Error message\r\n * @param {object} context - Additional context\r\n */\r\nexport const captureCustomError = (message, context = {}) => {\r\n  errorMonitor.captureError({\r\n    type: 'custom',\r\n    message,\r\n    context,\r\n    timestamp: new Date().toISOString()\r\n  });\r\n};\r\n\r\n/**\r\n * Get error monitoring dashboard data\r\n * @returns {object} - Dashboard data\r\n */\r\nexport const getErrorDashboardData = () => {\r\n  return {\r\n    stats: errorMonitor.getErrorStats(),\r\n    recentErrors: errorMonitor.getRecentErrors(),\r\n    topErrors: errorMonitor.getTopErrors()\r\n  };\r\n};\r\n\r\nexport default ErrorMonitor;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}