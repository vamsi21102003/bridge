{"ast":null,"code":"/**\r\n * Memory Optimization Utilities\r\n * Provides memory leak detection and optimization for the integrated system\r\n */\n\nexport class MemoryOptimizer {\n  constructor() {\n    this.memorySnapshots = [];\n    this.cleanupTasks = new Set();\n    this.isMonitoring = false;\n  }\n\n  /**\r\n   * Initialize memory optimization\r\n   */\n  initialize() {\n    if (this.isMonitoring) return;\n    this.startMemoryMonitoring();\n    this.setupCleanupTasks();\n    this.isMonitoring = true;\n    console.log('ðŸ§  Memory optimization initialized');\n  }\n\n  /**\r\n   * Start memory monitoring\r\n   */\n  startMemoryMonitoring() {\n    if (!performance.memory) {\n      console.warn('Memory API not available in this browser');\n      return;\n    }\n\n    // Take initial snapshot\n    this.takeMemorySnapshot('initial');\n\n    // Monitor memory usage every 30 seconds\n    setInterval(() => {\n      this.takeMemorySnapshot('periodic');\n      this.analyzeMemoryTrends();\n    }, 30000);\n  }\n\n  /**\r\n   * Take memory snapshot\r\n   */\n  takeMemorySnapshot(type = 'manual') {\n    if (!performance.memory) return null;\n    const snapshot = {\n      timestamp: Date.now(),\n      type,\n      used: performance.memory.usedJSHeapSize,\n      total: performance.memory.totalJSHeapSize,\n      limit: performance.memory.jsHeapSizeLimit,\n      usagePercentage: performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit * 100\n    };\n    this.memorySnapshots.push(snapshot);\n\n    // Keep only last 50 snapshots\n    if (this.memorySnapshots.length > 50) {\n      this.memorySnapshots = this.memorySnapshots.slice(-50);\n    }\n\n    // Check for memory warnings\n    if (snapshot.usagePercentage > 80) {\n      console.warn('ðŸš¨ High memory usage detected:', snapshot.usagePercentage.toFixed(2) + '%');\n      this.triggerMemoryCleanup();\n    }\n    return snapshot;\n  }\n\n  /**\r\n   * Analyze memory trends\r\n   */\n  analyzeMemoryTrends() {\n    if (this.memorySnapshots.length < 5) return;\n    const recent = this.memorySnapshots.slice(-5);\n    const trend = this.calculateMemoryTrend(recent);\n    if (trend.isIncreasing && trend.rate > 1024 * 1024) {\n      // 1MB increase per snapshot\n      console.warn('ðŸš¨ Memory leak detected - increasing trend:', trend);\n    }\n  }\n\n  /**\r\n   * Calculate memory trend\r\n   */\n  calculateMemoryTrend(snapshots) {\n    if (snapshots.length < 2) return {\n      isIncreasing: false,\n      rate: 0\n    };\n    const first = snapshots[0];\n    const last = snapshots[snapshots.length - 1];\n    const timeDiff = last.timestamp - first.timestamp;\n    const memoryDiff = last.used - first.used;\n    const rate = memoryDiff / (timeDiff / 1000); // bytes per second\n\n    return {\n      isIncreasing: memoryDiff > 0,\n      rate: rate,\n      totalIncrease: memoryDiff,\n      timeSpan: timeDiff\n    };\n  }\n\n  /**\r\n   * Setup cleanup tasks\r\n   */\n  setupCleanupTasks() {\n    // Cleanup on page unload\n    window.addEventListener('beforeunload', () => {\n      this.performCleanup();\n    });\n  }\n\n  /**\r\n   * Trigger memory cleanup\r\n   */\n  triggerMemoryCleanup() {\n    console.log('ðŸ§¹ Triggering memory cleanup...');\n\n    // Force garbage collection if available\n    if (window.gc) {\n      window.gc();\n    }\n\n    // Perform custom cleanup tasks\n    this.performCleanup();\n\n    // Take snapshot after cleanup\n    setTimeout(() => {\n      this.takeMemorySnapshot('post-cleanup');\n    }, 1000);\n  }\n\n  /**\r\n   * Perform cleanup tasks\r\n   */\n  performCleanup() {\n    // Execute all registered cleanup tasks\n    this.cleanupTasks.forEach(task => {\n      try {\n        task();\n      } catch (error) {\n        console.error('Error in cleanup task:', error);\n      }\n    });\n  }\n\n  /**\r\n   * Register cleanup task\r\n   */\n  registerCleanupTask(task) {\n    this.cleanupTasks.add(task);\n    return () => this.cleanupTasks.delete(task); // Return unregister function\n  }\n\n  /**\r\n   * Get memory statistics\r\n   */\n  getMemoryStats() {\n    const current = this.takeMemorySnapshot('stats');\n    const trend = this.memorySnapshots.length > 1 ? this.calculateMemoryTrend(this.memorySnapshots.slice(-10)) : null;\n    return {\n      current,\n      trend,\n      snapshots: this.memorySnapshots.length,\n      cleanupTasks: this.cleanupTasks.size,\n      isMonitoring: this.isMonitoring\n    };\n  }\n\n  /**\r\n   * Generate memory report\r\n   */\n  generateMemoryReport() {\n    const stats = this.getMemoryStats();\n    const recommendations = this.getMemoryRecommendations(stats);\n    return {\n      timestamp: new Date().toISOString(),\n      stats,\n      recommendations,\n      snapshots: this.memorySnapshots.slice(-10) // Last 10 snapshots\n    };\n  }\n\n  /**\r\n   * Get memory optimization recommendations\r\n   */\n  getMemoryRecommendations(stats) {\n    const recommendations = [];\n    if (stats.current && stats.current.usagePercentage > 70) {\n      recommendations.push({\n        type: 'high-usage',\n        priority: 'high',\n        message: 'Memory usage is high. Consider implementing lazy loading and component cleanup.'\n      });\n    }\n    if (stats.trend && stats.trend.isIncreasing && stats.trend.rate > 512 * 1024) {\n      recommendations.push({\n        type: 'memory-leak',\n        priority: 'critical',\n        message: 'Potential memory leak detected. Review component lifecycle and event listener cleanup.'\n      });\n    }\n    return recommendations;\n  }\n}\n\n// Create singleton instance\nexport const memoryOptimizer = new MemoryOptimizer();\n\n/**\r\n * Initialize memory optimization\r\n */\nexport const initializeMemoryOptimization = () => {\n  memoryOptimizer.initialize();\n  console.log('ðŸ§  Memory optimization system initialized');\n};\n\n/**\r\n * Get memory optimization data\r\n */\nexport const getMemoryOptimizationData = () => {\n  return memoryOptimizer.generateMemoryReport();\n};\n\n/**\r\n * Register a cleanup task\r\n */\nexport const registerCleanupTask = task => {\n  return memoryOptimizer.registerCleanupTask(task);\n};\n\n/**\r\n * Trigger manual memory cleanup\r\n */\nexport const triggerMemoryCleanup = () => {\n  memoryOptimizer.triggerMemoryCleanup();\n};\nexport default MemoryOptimizer;","map":{"version":3,"names":["MemoryOptimizer","constructor","memorySnapshots","cleanupTasks","Set","isMonitoring","initialize","startMemoryMonitoring","setupCleanupTasks","console","log","performance","memory","warn","takeMemorySnapshot","setInterval","analyzeMemoryTrends","type","snapshot","timestamp","Date","now","used","usedJSHeapSize","total","totalJSHeapSize","limit","jsHeapSizeLimit","usagePercentage","push","length","slice","toFixed","triggerMemoryCleanup","recent","trend","calculateMemoryTrend","isIncreasing","rate","snapshots","first","last","timeDiff","memoryDiff","totalIncrease","timeSpan","window","addEventListener","performCleanup","gc","setTimeout","forEach","task","error","registerCleanupTask","add","delete","getMemoryStats","current","size","generateMemoryReport","stats","recommendations","getMemoryRecommendations","toISOString","priority","message","memoryOptimizer","initializeMemoryOptimization","getMemoryOptimizationData"],"sources":["D:/MCA/BPUT_Hackathon/Last_hope/bridge/src/utils/memoryOptimizer.js"],"sourcesContent":["/**\r\n * Memory Optimization Utilities\r\n * Provides memory leak detection and optimization for the integrated system\r\n */\r\n\r\nexport class MemoryOptimizer {\r\n  constructor() {\r\n    this.memorySnapshots = [];\r\n    this.cleanupTasks = new Set();\r\n    this.isMonitoring = false;\r\n  }\r\n\r\n  /**\r\n   * Initialize memory optimization\r\n   */\r\n  initialize() {\r\n    if (this.isMonitoring) return;\r\n\r\n    this.startMemoryMonitoring();\r\n    this.setupCleanupTasks();\r\n    \r\n    this.isMonitoring = true;\r\n    console.log('ðŸ§  Memory optimization initialized');\r\n  }\r\n\r\n  /**\r\n   * Start memory monitoring\r\n   */\r\n  startMemoryMonitoring() {\r\n    if (!performance.memory) {\r\n      console.warn('Memory API not available in this browser');\r\n      return;\r\n    }\r\n\r\n    // Take initial snapshot\r\n    this.takeMemorySnapshot('initial');\r\n\r\n    // Monitor memory usage every 30 seconds\r\n    setInterval(() => {\r\n      this.takeMemorySnapshot('periodic');\r\n      this.analyzeMemoryTrends();\r\n    }, 30000);\r\n  }\r\n\r\n  /**\r\n   * Take memory snapshot\r\n   */\r\n  takeMemorySnapshot(type = 'manual') {\r\n    if (!performance.memory) return null;\r\n\r\n    const snapshot = {\r\n      timestamp: Date.now(),\r\n      type,\r\n      used: performance.memory.usedJSHeapSize,\r\n      total: performance.memory.totalJSHeapSize,\r\n      limit: performance.memory.jsHeapSizeLimit,\r\n      usagePercentage: (performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit) * 100\r\n    };\r\n\r\n    this.memorySnapshots.push(snapshot);\r\n    \r\n    // Keep only last 50 snapshots\r\n    if (this.memorySnapshots.length > 50) {\r\n      this.memorySnapshots = this.memorySnapshots.slice(-50);\r\n    }\r\n\r\n    // Check for memory warnings\r\n    if (snapshot.usagePercentage > 80) {\r\n      console.warn('ðŸš¨ High memory usage detected:', snapshot.usagePercentage.toFixed(2) + '%');\r\n      this.triggerMemoryCleanup();\r\n    }\r\n\r\n    return snapshot;\r\n  }\r\n\r\n  /**\r\n   * Analyze memory trends\r\n   */\r\n  analyzeMemoryTrends() {\r\n    if (this.memorySnapshots.length < 5) return;\r\n\r\n    const recent = this.memorySnapshots.slice(-5);\r\n    const trend = this.calculateMemoryTrend(recent);\r\n\r\n    if (trend.isIncreasing && trend.rate > 1024 * 1024) { // 1MB increase per snapshot\r\n      console.warn('ðŸš¨ Memory leak detected - increasing trend:', trend);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate memory trend\r\n   */\r\n  calculateMemoryTrend(snapshots) {\r\n    if (snapshots.length < 2) return { isIncreasing: false, rate: 0 };\r\n\r\n    const first = snapshots[0];\r\n    const last = snapshots[snapshots.length - 1];\r\n    const timeDiff = last.timestamp - first.timestamp;\r\n    const memoryDiff = last.used - first.used;\r\n    const rate = memoryDiff / (timeDiff / 1000); // bytes per second\r\n\r\n    return {\r\n      isIncreasing: memoryDiff > 0,\r\n      rate: rate,\r\n      totalIncrease: memoryDiff,\r\n      timeSpan: timeDiff\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Setup cleanup tasks\r\n   */\r\n  setupCleanupTasks() {\r\n    // Cleanup on page unload\r\n    window.addEventListener('beforeunload', () => {\r\n      this.performCleanup();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Trigger memory cleanup\r\n   */\r\n  triggerMemoryCleanup() {\r\n    console.log('ðŸ§¹ Triggering memory cleanup...');\r\n    \r\n    // Force garbage collection if available\r\n    if (window.gc) {\r\n      window.gc();\r\n    }\r\n    \r\n    // Perform custom cleanup tasks\r\n    this.performCleanup();\r\n    \r\n    // Take snapshot after cleanup\r\n    setTimeout(() => {\r\n      this.takeMemorySnapshot('post-cleanup');\r\n    }, 1000);\r\n  }\r\n\r\n  /**\r\n   * Perform cleanup tasks\r\n   */\r\n  performCleanup() {\r\n    // Execute all registered cleanup tasks\r\n    this.cleanupTasks.forEach(task => {\r\n      try {\r\n        task();\r\n      } catch (error) {\r\n        console.error('Error in cleanup task:', error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Register cleanup task\r\n   */\r\n  registerCleanupTask(task) {\r\n    this.cleanupTasks.add(task);\r\n    return () => this.cleanupTasks.delete(task); // Return unregister function\r\n  }\r\n\r\n  /**\r\n   * Get memory statistics\r\n   */\r\n  getMemoryStats() {\r\n    const current = this.takeMemorySnapshot('stats');\r\n    const trend = this.memorySnapshots.length > 1 ? \r\n      this.calculateMemoryTrend(this.memorySnapshots.slice(-10)) : null;\r\n    \r\n    return {\r\n      current,\r\n      trend,\r\n      snapshots: this.memorySnapshots.length,\r\n      cleanupTasks: this.cleanupTasks.size,\r\n      isMonitoring: this.isMonitoring\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate memory report\r\n   */\r\n  generateMemoryReport() {\r\n    const stats = this.getMemoryStats();\r\n    const recommendations = this.getMemoryRecommendations(stats);\r\n    \r\n    return {\r\n      timestamp: new Date().toISOString(),\r\n      stats,\r\n      recommendations,\r\n      snapshots: this.memorySnapshots.slice(-10) // Last 10 snapshots\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get memory optimization recommendations\r\n   */\r\n  getMemoryRecommendations(stats) {\r\n    const recommendations = [];\r\n    \r\n    if (stats.current && stats.current.usagePercentage > 70) {\r\n      recommendations.push({\r\n        type: 'high-usage',\r\n        priority: 'high',\r\n        message: 'Memory usage is high. Consider implementing lazy loading and component cleanup.'\r\n      });\r\n    }\r\n    \r\n    if (stats.trend && stats.trend.isIncreasing && stats.trend.rate > 512 * 1024) {\r\n      recommendations.push({\r\n        type: 'memory-leak',\r\n        priority: 'critical',\r\n        message: 'Potential memory leak detected. Review component lifecycle and event listener cleanup.'\r\n      });\r\n    }\r\n    \r\n    return recommendations;\r\n  }\r\n}\r\n\r\n// Create singleton instance\r\nexport const memoryOptimizer = new MemoryOptimizer();\r\n\r\n/**\r\n * Initialize memory optimization\r\n */\r\nexport const initializeMemoryOptimization = () => {\r\n  memoryOptimizer.initialize();\r\n  console.log('ðŸ§  Memory optimization system initialized');\r\n};\r\n\r\n/**\r\n * Get memory optimization data\r\n */\r\nexport const getMemoryOptimizationData = () => {\r\n  return memoryOptimizer.generateMemoryReport();\r\n};\r\n\r\n/**\r\n * Register a cleanup task\r\n */\r\nexport const registerCleanupTask = (task) => {\r\n  return memoryOptimizer.registerCleanupTask(task);\r\n};\r\n\r\n/**\r\n * Trigger manual memory cleanup\r\n */\r\nexport const triggerMemoryCleanup = () => {\r\n  memoryOptimizer.triggerMemoryCleanup();\r\n};\r\n\r\nexport default MemoryOptimizer;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}