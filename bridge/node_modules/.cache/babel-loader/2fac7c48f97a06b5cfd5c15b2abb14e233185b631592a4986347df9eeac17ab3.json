{"ast":null,"code":"import { NAVIGATION_STATES, STUDENT_PAGES } from '../constants/navigationStates';\nimport { handleNavigationError } from './navigationErrorHandler';\n\n/**\r\n * Enhanced navigation error handler with retry mechanisms and user feedback\r\n */\nexport class EnhancedNavigationErrorHandler {\n  constructor() {\n    this.errorCount = 0;\n    this.maxRetries = 3;\n    this.errorHistory = [];\n  }\n\n  /**\r\n   * Handle navigation errors with enhanced recovery\r\n   * @param {Error} error - The navigation error\r\n   * @param {string} targetState - The state we were trying to navigate to\r\n   * @param {function} setAppState - Function to update app state\r\n   * @param {object} currentAppState - Current application state\r\n   * @returns {Promise<string>} - The recovery state\r\n   */\n  async handleNavigationError(error, targetState, setAppState, currentAppState) {\n    this.errorCount++;\n    this.errorHistory.push({\n      error: error.message,\n      targetState,\n      timestamp: new Date().toISOString(),\n      currentState: currentAppState.currentPage\n    });\n    console.error('Enhanced navigation error:', {\n      error,\n      targetState,\n      errorCount: this.errorCount,\n      currentState: currentAppState.currentPage\n    });\n\n    // If we've exceeded max retries, go to safe state\n    if (this.errorCount >= this.maxRetries) {\n      console.warn('Max navigation retries exceeded, going to safe state');\n      return this.goToSafeState(setAppState, currentAppState);\n    }\n\n    // Try to recover based on error type\n    return this.attemptRecovery(error, targetState, setAppState, currentAppState);\n  }\n\n  /**\r\n   * Attempt to recover from navigation error\r\n   * @param {Error} error - The navigation error\r\n   * @param {string} targetState - The state we were trying to navigate to\r\n   * @param {function} setAppState - Function to update app state\r\n   * @param {object} currentAppState - Current application state\r\n   * @returns {Promise<string>} - The recovery state\r\n   */\n  async attemptRecovery(error, targetState, setAppState, currentAppState) {\n    // Check if it's a permission/authentication error\n    if (this.isAuthenticationError(error, targetState, currentAppState)) {\n      return this.handleAuthenticationError(setAppState, currentAppState);\n    }\n\n    // Check if it's a component loading error\n    if (this.isComponentError(error)) {\n      return this.handleComponentError(targetState, setAppState, currentAppState);\n    }\n\n    // Check if it's a routing error\n    if (this.isRoutingError(error)) {\n      return this.handleRoutingError(targetState, setAppState, currentAppState);\n    }\n\n    // Default fallback\n    return this.fallbackNavigation(targetState, setAppState, currentAppState);\n  }\n\n  /**\r\n   * Check if error is authentication related\r\n   */\n  isAuthenticationError(error, targetState, currentAppState) {\n    const authRequiredStates = [NAVIGATION_STATES.PROFILE_COMPLETION, NAVIGATION_STATES.STUDENT_FORM, NAVIGATION_STATES.STUDENT_DASHBOARD];\n    return authRequiredStates.includes(targetState) && !currentAppState.isAuthenticated;\n  }\n\n  /**\r\n   * Handle authentication errors\r\n   */\n  handleAuthenticationError(setAppState, currentAppState) {\n    console.log('Authentication error detected, redirecting to login');\n    setAppState(prev => ({\n      ...prev,\n      currentPage: NAVIGATION_STATES.LOGIN,\n      userData: null,\n      isAuthenticated: false\n    }));\n    return NAVIGATION_STATES.LOGIN;\n  }\n\n  /**\r\n   * Check if error is component loading related\r\n   */\n  isComponentError(error) {\n    const componentErrorKeywords = ['chunk', 'loading', 'import', 'module'];\n    return componentErrorKeywords.some(keyword => error.message.toLowerCase().includes(keyword));\n  }\n\n  /**\r\n   * Handle component loading errors\r\n   */\n  async handleComponentError(targetState, setAppState, currentAppState) {\n    console.log('Component loading error detected, attempting reload');\n\n    // Try to reload the page after a short delay\n    setTimeout(() => {\n      window.location.reload();\n    }, 1000);\n\n    // In the meantime, show a loading state\n    return currentAppState.currentPage;\n  }\n\n  /**\r\n   * Check if error is routing related\r\n   */\n  isRoutingError(error) {\n    const routingErrorKeywords = ['route', 'path', 'navigation', 'history'];\n    return routingErrorKeywords.some(keyword => error.message.toLowerCase().includes(keyword));\n  }\n\n  /**\r\n   * Handle routing errors\r\n   */\n  handleRoutingError(targetState, setAppState, currentAppState) {\n    console.log('Routing error detected, using fallback navigation');\n\n    // Use the original navigation error handler as fallback\n    return handleNavigationError(error, targetState, fallbackState => {\n      setAppState(prev => ({\n        ...prev,\n        currentPage: fallbackState\n      }));\n    });\n  }\n\n  /**\r\n   * Fallback navigation when other recovery methods fail\r\n   */\n  fallbackNavigation(targetState, setAppState, currentAppState) {\n    console.log('Using fallback navigation');\n    let fallbackState;\n\n    // Determine safe fallback based on user state\n    if (currentAppState.isAuthenticated && currentAppState.userType === 'student') {\n      fallbackState = NAVIGATION_STATES.STUDENT_DASHBOARD;\n    } else if (currentAppState.isAuthenticated) {\n      fallbackState = NAVIGATION_STATES.BRIDGE_HOME;\n    } else {\n      fallbackState = NAVIGATION_STATES.BRIDGE_HOME;\n    }\n    setAppState(prev => ({\n      ...prev,\n      currentPage: fallbackState\n    }));\n    return fallbackState;\n  }\n\n  /**\r\n   * Go to the safest possible state\r\n   */\n  goToSafeState(setAppState, currentAppState) {\n    console.log('Going to safe state due to repeated errors');\n\n    // Clear error state and go to bridge home\n    this.reset();\n    setAppState(prev => ({\n      ...prev,\n      currentPage: NAVIGATION_STATES.BRIDGE_HOME,\n      currentStudentPage: STUDENT_PAGES.HOME\n    }));\n    return NAVIGATION_STATES.BRIDGE_HOME;\n  }\n\n  /**\r\n   * Reset error tracking\r\n   */\n  reset() {\n    this.errorCount = 0;\n    this.errorHistory = [];\n  }\n\n  /**\r\n   * Get error statistics\r\n   */\n  getErrorStats() {\n    return {\n      errorCount: this.errorCount,\n      errorHistory: this.errorHistory,\n      maxRetries: this.maxRetries\n    };\n  }\n}\n\n// Create singleton instance\nexport const enhancedNavigationErrorHandler = new EnhancedNavigationErrorHandler();\n\n/**\r\n * Convenience function to handle navigation errors\r\n * @param {Error} error - The navigation error\r\n * @param {string} targetState - The state we were trying to navigate to\r\n * @param {function} setAppState - Function to update app state\r\n * @param {object} currentAppState - Current application state\r\n * @returns {Promise<string>} - The recovery state\r\n */\nexport const handleEnhancedNavigationError = async (error, targetState, setAppState, currentAppState) => {\n  return enhancedNavigationErrorHandler.handleNavigationError(error, targetState, setAppState, currentAppState);\n};\nexport default EnhancedNavigationErrorHandler;","map":{"version":3,"names":["NAVIGATION_STATES","STUDENT_PAGES","handleNavigationError","EnhancedNavigationErrorHandler","constructor","errorCount","maxRetries","errorHistory","error","targetState","setAppState","currentAppState","push","message","timestamp","Date","toISOString","currentState","currentPage","console","warn","goToSafeState","attemptRecovery","isAuthenticationError","handleAuthenticationError","isComponentError","handleComponentError","isRoutingError","handleRoutingError","fallbackNavigation","authRequiredStates","PROFILE_COMPLETION","STUDENT_FORM","STUDENT_DASHBOARD","includes","isAuthenticated","log","prev","LOGIN","userData","componentErrorKeywords","some","keyword","toLowerCase","setTimeout","window","location","reload","routingErrorKeywords","fallbackState","userType","BRIDGE_HOME","reset","currentStudentPage","HOME","getErrorStats","enhancedNavigationErrorHandler","handleEnhancedNavigationError"],"sources":["D:/MCA/BPUT_Hackathon/Last_hope/bridge/src/utils/enhancedNavigationErrorHandler.js"],"sourcesContent":["import { NAVIGATION_STATES, STUDENT_PAGES } from '../constants/navigationStates';\r\nimport { handleNavigationError } from './navigationErrorHandler';\r\n\r\n/**\r\n * Enhanced navigation error handler with retry mechanisms and user feedback\r\n */\r\nexport class EnhancedNavigationErrorHandler {\r\n  constructor() {\r\n    this.errorCount = 0;\r\n    this.maxRetries = 3;\r\n    this.errorHistory = [];\r\n  }\r\n\r\n  /**\r\n   * Handle navigation errors with enhanced recovery\r\n   * @param {Error} error - The navigation error\r\n   * @param {string} targetState - The state we were trying to navigate to\r\n   * @param {function} setAppState - Function to update app state\r\n   * @param {object} currentAppState - Current application state\r\n   * @returns {Promise<string>} - The recovery state\r\n   */\r\n  async handleNavigationError(error, targetState, setAppState, currentAppState) {\r\n    this.errorCount++;\r\n    this.errorHistory.push({\r\n      error: error.message,\r\n      targetState,\r\n      timestamp: new Date().toISOString(),\r\n      currentState: currentAppState.currentPage\r\n    });\r\n\r\n    console.error('Enhanced navigation error:', {\r\n      error,\r\n      targetState,\r\n      errorCount: this.errorCount,\r\n      currentState: currentAppState.currentPage\r\n    });\r\n\r\n    // If we've exceeded max retries, go to safe state\r\n    if (this.errorCount >= this.maxRetries) {\r\n      console.warn('Max navigation retries exceeded, going to safe state');\r\n      return this.goToSafeState(setAppState, currentAppState);\r\n    }\r\n\r\n    // Try to recover based on error type\r\n    return this.attemptRecovery(error, targetState, setAppState, currentAppState);\r\n  }\r\n\r\n  /**\r\n   * Attempt to recover from navigation error\r\n   * @param {Error} error - The navigation error\r\n   * @param {string} targetState - The state we were trying to navigate to\r\n   * @param {function} setAppState - Function to update app state\r\n   * @param {object} currentAppState - Current application state\r\n   * @returns {Promise<string>} - The recovery state\r\n   */\r\n  async attemptRecovery(error, targetState, setAppState, currentAppState) {\r\n    // Check if it's a permission/authentication error\r\n    if (this.isAuthenticationError(error, targetState, currentAppState)) {\r\n      return this.handleAuthenticationError(setAppState, currentAppState);\r\n    }\r\n\r\n    // Check if it's a component loading error\r\n    if (this.isComponentError(error)) {\r\n      return this.handleComponentError(targetState, setAppState, currentAppState);\r\n    }\r\n\r\n    // Check if it's a routing error\r\n    if (this.isRoutingError(error)) {\r\n      return this.handleRoutingError(targetState, setAppState, currentAppState);\r\n    }\r\n\r\n    // Default fallback\r\n    return this.fallbackNavigation(targetState, setAppState, currentAppState);\r\n  }\r\n\r\n  /**\r\n   * Check if error is authentication related\r\n   */\r\n  isAuthenticationError(error, targetState, currentAppState) {\r\n    const authRequiredStates = [\r\n      NAVIGATION_STATES.PROFILE_COMPLETION,\r\n      NAVIGATION_STATES.STUDENT_FORM,\r\n      NAVIGATION_STATES.STUDENT_DASHBOARD\r\n    ];\r\n\r\n    return authRequiredStates.includes(targetState) && !currentAppState.isAuthenticated;\r\n  }\r\n\r\n  /**\r\n   * Handle authentication errors\r\n   */\r\n  handleAuthenticationError(setAppState, currentAppState) {\r\n    console.log('Authentication error detected, redirecting to login');\r\n    \r\n    setAppState(prev => ({\r\n      ...prev,\r\n      currentPage: NAVIGATION_STATES.LOGIN,\r\n      userData: null,\r\n      isAuthenticated: false\r\n    }));\r\n\r\n    return NAVIGATION_STATES.LOGIN;\r\n  }\r\n\r\n  /**\r\n   * Check if error is component loading related\r\n   */\r\n  isComponentError(error) {\r\n    const componentErrorKeywords = ['chunk', 'loading', 'import', 'module'];\r\n    return componentErrorKeywords.some(keyword => \r\n      error.message.toLowerCase().includes(keyword)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Handle component loading errors\r\n   */\r\n  async handleComponentError(targetState, setAppState, currentAppState) {\r\n    console.log('Component loading error detected, attempting reload');\r\n    \r\n    // Try to reload the page after a short delay\r\n    setTimeout(() => {\r\n      window.location.reload();\r\n    }, 1000);\r\n\r\n    // In the meantime, show a loading state\r\n    return currentAppState.currentPage;\r\n  }\r\n\r\n  /**\r\n   * Check if error is routing related\r\n   */\r\n  isRoutingError(error) {\r\n    const routingErrorKeywords = ['route', 'path', 'navigation', 'history'];\r\n    return routingErrorKeywords.some(keyword => \r\n      error.message.toLowerCase().includes(keyword)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Handle routing errors\r\n   */\r\n  handleRoutingError(targetState, setAppState, currentAppState) {\r\n    console.log('Routing error detected, using fallback navigation');\r\n    \r\n    // Use the original navigation error handler as fallback\r\n    return handleNavigationError(error, targetState, (fallbackState) => {\r\n      setAppState(prev => ({ ...prev, currentPage: fallbackState }));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fallback navigation when other recovery methods fail\r\n   */\r\n  fallbackNavigation(targetState, setAppState, currentAppState) {\r\n    console.log('Using fallback navigation');\r\n    \r\n    let fallbackState;\r\n    \r\n    // Determine safe fallback based on user state\r\n    if (currentAppState.isAuthenticated && currentAppState.userType === 'student') {\r\n      fallbackState = NAVIGATION_STATES.STUDENT_DASHBOARD;\r\n    } else if (currentAppState.isAuthenticated) {\r\n      fallbackState = NAVIGATION_STATES.BRIDGE_HOME;\r\n    } else {\r\n      fallbackState = NAVIGATION_STATES.BRIDGE_HOME;\r\n    }\r\n\r\n    setAppState(prev => ({ ...prev, currentPage: fallbackState }));\r\n    return fallbackState;\r\n  }\r\n\r\n  /**\r\n   * Go to the safest possible state\r\n   */\r\n  goToSafeState(setAppState, currentAppState) {\r\n    console.log('Going to safe state due to repeated errors');\r\n    \r\n    // Clear error state and go to bridge home\r\n    this.reset();\r\n    \r\n    setAppState(prev => ({\r\n      ...prev,\r\n      currentPage: NAVIGATION_STATES.BRIDGE_HOME,\r\n      currentStudentPage: STUDENT_PAGES.HOME\r\n    }));\r\n\r\n    return NAVIGATION_STATES.BRIDGE_HOME;\r\n  }\r\n\r\n  /**\r\n   * Reset error tracking\r\n   */\r\n  reset() {\r\n    this.errorCount = 0;\r\n    this.errorHistory = [];\r\n  }\r\n\r\n  /**\r\n   * Get error statistics\r\n   */\r\n  getErrorStats() {\r\n    return {\r\n      errorCount: this.errorCount,\r\n      errorHistory: this.errorHistory,\r\n      maxRetries: this.maxRetries\r\n    };\r\n  }\r\n}\r\n\r\n// Create singleton instance\r\nexport const enhancedNavigationErrorHandler = new EnhancedNavigationErrorHandler();\r\n\r\n/**\r\n * Convenience function to handle navigation errors\r\n * @param {Error} error - The navigation error\r\n * @param {string} targetState - The state we were trying to navigate to\r\n * @param {function} setAppState - Function to update app state\r\n * @param {object} currentAppState - Current application state\r\n * @returns {Promise<string>} - The recovery state\r\n */\r\nexport const handleEnhancedNavigationError = async (error, targetState, setAppState, currentAppState) => {\r\n  return enhancedNavigationErrorHandler.handleNavigationError(error, targetState, setAppState, currentAppState);\r\n};\r\n\r\nexport default EnhancedNavigationErrorHandler;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}